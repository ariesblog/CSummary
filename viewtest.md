# Linux C 面试题总结

转载出处：https://blog.csdn.net/jsh13417/article/details/39861929

### 1、进程和线程的区别，及优劣性比较
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
2) 线程的划分尺度小于进程，使得多线程程序的并发性高。
3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
1.3 优缺点:
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。


线程是指进程内的一个执行单元,也是进程内的可调度实体.
与进程的区别:
(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源. 
(4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销


### 2、局部变量能否和全局变量重名？


　　答：能，局部会屏蔽全局。要用全局变量，需要使用"::"


　　局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。


### 3、如何引用一个已经定义过的全局变量？


　　答：extern


　　可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。
### 4、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？


　　答：可以，在不同的C文件中以static形式来声明同名全局变量。
1、关键字static的作用是什么？
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数
据和代码范围的好处和重要性。


### 5、“引用”与指针的区别是什么？
答 、1) 引用必须被初始化，指针不必。
2) 引用初始化以后不能被改变，指针可以改变所指的对象。
3) 不存在指向空值的引用，但是存在指向空值的指针。
指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。 
流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。  

### 6、什么是平衡二叉树？
答 ：左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。


### 7、堆栈溢出一般是由什么原因导致的？
答 ：1.没有回收垃圾资源
2.层次太深的递归调用

### 8、什么是预编译,何时需要预编译?
答：预编译又称为预处理,是做些代码文本的替换工作。处理#开头的指令,比如拷贝#include包含的文件代码，#define宏定义的替换,条件编译等，就是为编译做的预备工作的阶段，主要处理#开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。
c编译系统在对程序进行通常的编译之前，先进行预处理。c提供的预处理功能主要有以下三种：1）宏定义　2）文件包含　3）条件编译

### 9、关键字volatile有什么含意 并给出三个不同的例子。
答：一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
24、三种基本的数据模型
答：按照数据结构类型的不同，将数据模型划分为层次模型、网状模型和关系模型。


### 10、结构与联合有和区别？
答：(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。 
 (2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的
、分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。
答：BOOL :    if ( !a ) or if(a)
int :     if ( a == 0)
float :   const EXPRESSION EXP = 0.000001
          if ( a < EXP && a >-EXP)
pointer : if ( a != NULL) or if(a == NULL) 


### 11、如何判断一段程序是由C 编译程序还是由C++编译程序编译的？
答：#ifdef __cplusplus
cout<<"c++";
#else
cout<<"c";
#endif
用两个栈实现一个队列的功能？要求给出算法和思路！
答 、设2个栈为A,B, 一开始均为空.
入队:
将新元素push入栈A;
出队:
(1)判断栈B是否为空；
(2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；
(3)将栈B的栈顶元素pop出；
这样实现的队列入队和出队的平摊复杂度都还是O(1), 比上面的几种方法要好



### 1 . 用预处理指令#define 声明一个常数，用以表明 1 年中有多少秒（忽略闰年问题）
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情：
&#8226;; #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
&#8226;; 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中
有多少秒而不是计算出实际的值，是更清晰而没有代价的。
&#8226;; 意识到这个表达式将使一个 16 位机的整型数溢出‐因此要用到长整型符号 L,告诉
编
译器这个常数是的长整型数。
&#8226;; 如果你在你的表达式中用到 UL（表示无符号长整型） ，那么你有了一个好的起点
。记住，第一印象很重要。

### 2 . 写一个“标准”宏 MIN ，这个宏输入两个参数并返回较小的一个。
#define MIN(A,B) （ （A） <= (B) ? (A) : (B))
这个测试是为下面的目的而设的：
&#8226;; 标识#define 在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作
符变为标准 C 的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能
达到要求的性能，嵌入代码经常是必须的方法。
&#8226;; 三重条件操作符的知识。这个操作符存在 C 语言中的原因是它使得编译器能产生
比
if‐then‐else 更优化的代码，了解这个用法是很重要的。
&#8226;; 懂得在宏中小心地把参数用括号括起来
&#8226;; 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事
？
least = MIN(*p++, b);

### 3. 预处理器标识#error 的目的是什么？
如果你不知道答案，请看参考文献 1。这问题对区分一个正常的伙计和一个书呆子是很有用
的。 只有书呆子才会读 C 语言课本的附录去找出象这种问题的答案。 当然如果你不是在找一
个书呆子，那么应试者最好希望自己不要知道答案。
死循环（Infinite loops）

### 4. 嵌入式系统中经常要用到无限循环，你怎么样用 C 编写死循环呢？
这个问题用几个解决方案。我首选的方案是：
while(1)
{
?}
一些程序员更喜欢如下方案：
for(;;)
{
?}
这个实现方式让我为难， 因为这个语法没有确切表达到底怎么回事。 如果一个应试者给出这
个作为方案， 我将用这个作为一个机会去探究他们这样做的基本原理。 如果他们的基本答案
是： “我被教着这样做，但从没有想到过为什么。 ”这会给我留下一个坏印象。
第三个方案是用 goto
Loop:
...
goto Loop;
应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是
一个想进入新领域的 BASIC/FORTRAN 程序员。
数据声明（Data declarations）
5. 用变量 a 给出下面的定义
a) 一个整型数（An integer）
b)一个指向整型数的指针（ A pointer to an integer）
c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to
 an intege）r
d)一个有 10 个整型数的数组（ An array of 10 integers）
e) 一个有 10 个指针的数组，该指针是指向一个整型数的。 （An array of 10 pointers to
integers）
f) 一个指向有 10 个整型数数组的指针（ A pointer to an array of 10 integers）
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a func
tion that takes an integer as an argument and returns an integer）
h)一个有 10 个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型
数
（ An array of ten pointers to functions that take an integer argument and retur
n an integer ）
答案是：
a) int a; // An integer
b) int *a; // A pointer to an integer
c) int **a; // A pointer to a pointer to an integer
d) int a[10]; // An array of 10 integers
e) int *a[10]; // An array of 10 pointers to integers
f) int (*a)[10]; // A pointer to an array of 10 integers
g) int (*a)(int); // A pointer to a function a that takes an integer argument an
d returns an integer
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integ
er argument and return an integer
人们经常声称这里有几个问题是那种要翻一下书才能回答的问题， 我同意这种说法。 当我写
这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望
被问到这个问题（或者相近的问题） 。因为在被面试的这段时间里，我确定我知道这个问题
的答案。应试者如果不知道所有的答案（或至少大部分答案） ，那么也就没有为这次面试做
准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？
Static

### 6. 关键字 static 的作用是什么？
这个简单的问题很少有人能回答完全。在 C 语言中，关键字 static 有三个明显的作用：
&#8226;; 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
&#8226;; 在模块内（但在函数体外） ，一个被声明为静态的变量可以被模块内所用函数访
问，但不能被模块外其它函数访问。它是一个本地的全局变量。
&#8226;; 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是
，这个函数被限制在声明它的模块的本地范围内使用。
大多数应试者能正确回答第一部分， 一部分能正确回答第二部分， 同是很少的人能懂得第三
部分。 这是一个应试者的严重的缺点， 因为他显然不懂得本地化数据和代码范围的好处和重
要性。

Const
### 7．关键字 const 有什么含意？
我只要一听到被面试者说： “const 意味着常数” ，我就知道我正在和一个业余者打交道。
去年 Dan Saks 已经在他的文章里完全概括了 const 的所有用法， 因此 ESP(译者： Embedded Sy
stems Programming)的每一位读者应该非常熟悉 const 能做什么和不能做什么.如果你从没有
读到那篇文章，只要能说出 const 意味着“只读”就可以了。尽管这个答案不是完全的答案
，但我接受它作为一个正确的答案。 （如果你想知道更详细的答案，仔细读一下 Saks 的文章
吧。 ）
如果应试者能正确回答这个问题，我将问他一个附加的问题：
下面的声明都是什么意思？
const int a;
int const a;
const int *a;
int * const a;
int const * a const;
/******/
前两个的作用是一样，a 是一个常整型数。第三个意味着 a 是一个指向常整型数的指针（也
就
是，整型数是不可修改的，但指针可以） 。第四个意思 a 是一个指向整型数的常指针（也就
是说，指针指向的整型数是可以修改的，但指针是不可修改的） 。最后一个意味着 a 是一个
指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修
改的） 。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，
也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为
什么还要如此看重关键字 const 呢？我也如下的几下理由：
&#8226;; 关键字 const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个
参数为常量是为了告诉了用户这个参数的应用目的。 如果你曾花很多时间清理其它人留下的
垃圾，你就会很快学会感谢这点多余的信息。 （当然，懂得用 const 的程序员很少会留下的
垃圾让别人来清理的。 ）
&#8226;; 通过给优化器一些附加的信息，使用关键字 const 也许能产生更紧凑的代码。
&#8226;; 合理地使用关键字 const 可以使编译器很自然地保护那些不希望被改变的参数， 防
止其被无意的代码修改。简而言之，这样可以减少 bug 的出现。
Volatile

### 8. 关键字 volatile 有什么含意?并给出三个不同的例子。
一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假
设这个变量的值了。 精确地说就是， 优化器在用到这个变量时必须每次都小心地重新读取这
个变量的值，而不是使用保存在寄存器里的备份。下面是 volatile 变量的几个例子：
&#8226;; 并行设备的硬件寄存器（如：状态寄存器）
&#8226;; 一个中断服务子程序中会访问到的非自动变量(Non‐automatic variables)
&#8226;; 多线程应用中被几个任务共享的变量
回答不出这个问题的人是不会被雇佣的。 我认为这是区分 C 程序员和嵌入式系统程序员的最
基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS 等等打交道，所有这些都要求用
到
volatile 变量。不懂得 volatile 的内容将会带来灾难。
假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样） ，我将稍微深究一下，看一
下这家伙是不是直正懂得 volatile 完全的重要性。
&#8226;; 一个参数既可以是 const 还可以是 volatile 吗？解释为什么。
&#8226;; 一个指针可以是 volatile 吗？解释为什么。
&#8226;; 下面的函数有什么错误：
int square(volatile int *ptr)
{
return *ptr * *ptr;
}
下面是答案：
&#8226;; 是的。一个例子是只读的状态寄存器。它是 volatile 因为它可能被意想不到地改
变。它是 const 因为程序不应该试图去修改它。
&#8226;; 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个 buf
fer 的指针时。
&#8226;; 这段代码有点变态。这段代码的目的是用来返指针*ptr 指向值的平方，但是，由
于*ptr 指向一个 volatile 型参数，编译器将产生类似下面的代码：
int square(volatile int *ptr)
{
int a,b;
a = *ptr;
b = *ptr;
return a * b;
}
由于*ptr 的值可能被意想不到地该变，因此 a 和 b 可能是不同的。结果，这段代码可能返不
是
你所期望的平方值！正确的代码如下：
long square(volatile int *ptr)
{
int a;
a = *ptr;
return a * a;
}


### 位操作（Bit manipulation）
9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量 a，写两段代码， 
第一个设置 a 的 bit 3，第二个清除 a 的 bit 3。在以上两个操作中，要保持其它位不变。
对这个问题有三种基本的反应
&#8226;; 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
&#8226;; 用 bit fields。
Bit fields 是被扔到 C 语言死角的东西，它保证你的代码在不同编
译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineo
n 为其较复杂的通信芯片写的驱动程序，它用到了 bit fields 因此完全对我无用，因为我的
编译器用其它的方式来实现 bit fields 的。从道德讲：永远不要让一个非嵌入式的家伙粘实
际硬件的边。
&#8226;; 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用
到的方法。最佳的解决方案如下：
#define BIT3 (0x1 << 3)
static int a;
void set_bit3(void) {
a |= BIT3;
}
void clear_bit3(void) {
a &= ~BIT3;
}
一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数， 这也是可以接受的。 我
希望看到几个要点：说明常数、|=和&=~操作。

访问固定的内存位置（Accessing fixed memory locations）
### 10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设
置一绝对地址为 0x67a9 的整型变量的值为 0xaa66。 编译器是一个纯粹的 ANSI 编译器。 写代
码
去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针
是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
int *ptr;
ptr = (int *)0x67a9;
*ptr = 0xaa55;
A more obscure approach is:
一个较晦涩的方法是：
*(int * const)(0x67a9) = 0xaa55;
即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。  

### 中断（Interrupts）
11. 中断是嵌入式系统中重要的组成部分， 这导致了很多编译开发商提供一种扩展—让标准
C 支持中断。具代表事实是，产生了一个新的关键字__interrupt。下面的代码就使用了__in
terrupt 关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
__interrupt double compute_area (double radius)
{
double area = PI * radius * radius;
printf("\nArea = %f", area);
return area;
}
这个函数有太多的错误了，以至让人不知从何说起了：
&#8226;; ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
&#8226;; ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
&#8226;; 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要
让额处的寄存器入栈，有些处理器/编译器就是不允许在 ISR 中做浮点运算。此外，ISR 应该
是短而有效率的，在 ISR 中做浮点运算是不明智的。
&#8226;; 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和
第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光
明了。
*****
代码例子（Code examples）
### 
12 . 下面的代码输出是什么，为什么？
void foo(void)
{
unsigned int a = 6;
int b = ‐20;
(a+b > 6) ? puts("> 6") : puts("<= 6");
}
这个问题测试你是否懂得 C 语言中的整数自动转换原则， 我发现有些开发者懂得极少这些东
西。不管如何，这无符号整型问题的答案是输出是 ”>6” 。原因是当表达式中存在有符号
类型和无符号类型时所有的操作数都自动转换为无符号类型。 因此‐20 变成了一个非常大
的
正整数，所以该表达式计算出的结果大于 6。这一点对于应当频繁用到无符号数据类型的嵌
入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。 
13. 评价下面的代码片断：
unsigned int zero = 0;
unsigned int compzero = 0xFFFF;
/*1's complement of zero */
对于一个 int 型不是 16 位的处理器为说，上面的代码是不正确的。应编写如下：
unsigned int compzero = ~0;
这一问题真正能揭露出应试者是否懂得处理器字长的重要性。 在我的经验里， 好的嵌入式程
序员非常准确地明白硬件的细节和它的局限，然而 PC 机程序往往把硬件作为一个无法避免
的
烦恼。
到了这个阶段， 应试者或者完全垂头丧气了或者信心满满志在必得。 如果显然应试者不是很
好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加
问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希
望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧…
动态内存分配（Dynamic memory allocation）
14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的
过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已
经在 ESP 杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到
的任何解释） ，所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿
出这么一个小节目：
下面的代码片段的输出是什么，为什么？
char *ptr;
if ((ptr = (char *)malloc(0)) ==
NULL)
else
puts("Got a null pointer");
puts("Got a valid pointer");
这是一个有趣的问题。最近在我的一个同事不经意把 0 值传给了函数 malloc，得到了一个合
法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是“Got a valid po
inter” 。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确
。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。
Typedef
:
15 Typedef 在 C 语言中频繁用以声明一个已经存在的数据类型的同义字。 也可以用预处理器
做类似的事。例如，思考一下下面的例子：
#define dPS struct s *
typedef struct s * tPS;
以上两种情况的意图都是要定义 dPS 和 tPS 作为一个指向结构 s 指针。哪种方法更好呢？
（
如果有的话）为什么？
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是： 
typedef 更好。思考下面的例子：
dPS p1,p2;
tPS p3,p4;
第一个扩展为
struct s * p1, p2;
.
上面的代码定义 p1 为一个指向结构的指，p2 为一个实际的结构，这也许不是你想要的。第
二
个例子正确地定义了 p3 和 p4 两个指针。
晦涩的语法
16 . C 语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
int a = 5, b = 7, c;
c = a+++b;
这个问题将做为这个测验的一个愉快的结尾。 不管你相不相信， 上面的例子是完全合乎语法
的。 问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题， 根据最处理原
则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：
c = a++ + b;
因此, 这段代码持行后 a = 6, b = 7, c = 12。
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。 
我发现这个问题的最大好处是这是一个关于代码编写风格， 代码的可读性， 代码的可修改性
的好的话题.
